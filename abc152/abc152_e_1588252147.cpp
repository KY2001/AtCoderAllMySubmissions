/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Kein Yukiyoshi
 */

#include "bits/stdc++.h"
#define int long long
#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); i++)
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define ALL(obj) begin(obj), end(obj)
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define LOWER_BOUND(A, key) distance(A.begin(), lower_bound(ALL(A), key))
#define UPPER_BOUND(A, key) distance(A.begin(), upper_bound(ALL(A), key))

using namespace std;
using ll      = long long;
const int MOD = (int)(1e9 + 7);
const int INF = (int)(1e13 + 7);

int bpm(int x, unsigned int y) {
  if (x == 0) return 0;
  if (y == 0) return 1;
  int ans   = 1;
  int digit = (int)((log((double)y) / log((double)2) / 1 + 1));
  x %= MOD;
  for (unsigned int i = 0; i < digit; i++) {
    if (((y >> i) & 1u) == 1) ans = ans * x % MOD;
    x = x * x % MOD;
  }
  return ans;
}
#define MAX_ 1000000
int inv_list[MAX_]{}; //inv_list[i-1] = inverse of i
void inv_continuous(int n) {
  inv_list[0] = 1;
  for (int i = 0; i < n; i++) {
    inv_list[i + 1] = MOD - (inv_list[(MOD % (i + 2)) - 1] * (MOD / (i + 2)) % MOD);
  }
}
vector<int> prime_factor;
void prime_factorization(int n) {
  while (n % 2 == 0) {
    n /= 2;
    prime_factor.push_back(2);
  }
  for (int i = 3; i < (int)(sqrt((double)n)) + 2; i += 2) {
    if (n % i == 0) {
      while (n % i == 0) {
        n /= i;
        prime_factor.push_back(i);
      }
    }
  }
  if (n != 1) {
    prime_factor.push_back(n);
  }
}
unordered_map<int, int> element_num; //change type if you need
template <class T>
void counter(T container) {
  for (int i = 0; i < container.size(); i++) {
    element_num[container[i]] += 1;
  }
}
class EFlatten {
public:
  static void solve(std::istream &cin, std::ostream &cout) {
    int N;
    cin >> N;
    vector<int> A(N);
    vector<int> LIST(1000000, 0);
    rep(i, N) {
      element_num  = {};
      prime_factor = {};
      cin >> A[i];
      prime_factorization(A[i]);
      counter(prime_factor);
      for (auto &i : prime_factor) {
        LIST[i - 1] = max(LIST[i - 1], element_num[i]);
      }
    }
    inv_continuous(MAX_);
    int LCM = 1;
    rep(i, 1000000) {
      if (LIST[i]) {
        LCM *= bpm(i + 1, LIST[i]);
        LCM %= MOD;
      }
    }
    int ans = 0;
    rep(i, N) {
      ans = (ans + LCM * inv_list[A[i] - 1]) % MOD;
    }
    cout << ans << endl;
  }
};


signed main() {
  EFlatten solver;
  std::istream& in(std::cin);
  std::ostream& out(std::cout);
  solver.solve(in, out);
  return 0;
}
